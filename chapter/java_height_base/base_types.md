# 基本数据类型

> [官网教程点这里](https://zq99299.gitbooks.io/java-tutorial/content/content/java/nutsandbolts/datatypes.html)

按类型分：

1. 字符类型：char
2. 布尔类似：boolean
3. 数值类型：byte、short、int、long、float、double

按长度分：

1. 未明确定义：boolean
2. 8位（1byte）：byte
3. 16位：char、short
4. 32位：int、float
5：64位：long，double

上面的8中类型，除去boolean和char外，其他的都是有符号的，范围大小是负数~正数。char数据类型是一个16位Unicode字符。它的最小值为'\u0000'（或0），最大值为'\uffff'（或65,535）。

## 位运算
位运算常用在 网络通信、协议解析、高性能编程中。

##### 左移操作 `<<`

_丢弃最高位，用0补位_

左移操作，数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以$$2^{1}$$

##### 右移操作 `>>`

_符号位不变，左边补上符号位_

正数右移，左边补0，负数右移，左边补1

##### 无符号右移操作 `>>>`

_无符号始终补0_

##### 按位与 `&`

_只有 1 & 1 = 1_

```bash
0000 0011  // 十进制 3
0000 0010  // 十进制 2
--------- 按位与
0000 0010  // 结果十进制为 2
```

##### 按位或 `|`

_只有 0 | 0 = 0_

##### 按位取反 `~`

_对二进制按位取反，即 0 变成 1，1 变成 0_


##### 按位异或 `^`

_只有 1 ^ 0 = 1 或则 0 ^ 1 = 1_

### 位运算总结

1. 位运算常用在 网络通信、协议解析、高性能编程中比较常见。
2. 位运算是针对整型的，进行位操作时，除long外，其他的类型会自动转成int
    
    ```bash
    如：byte ba = 127;ba << 2 
    这个运算，ba变量其实扩展成了int
    ```
3. 如果移动的位数超过了32位(long是64位)，那么编译器会对移动的位数取模
    
    如：对int移动33位，33 % 32 = 1，实际上只移动了一位
    
## 位运算实际应用举例

### 获取数值的16进制变形形式

下面这个例子：把变量b打印出它的16进制表现形式
```java
    char hex[] = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f'};

    int b = 0xf1;
    // b = 0xf1
    System.out.println("b = 0x" + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
```

以上程序有1个固定的16进制常量：0xF1 转换为二进制是：1111 0001

以下有几个比较常用的16进制常量：

* 0xFF : 一个F对应4个1，即：1111 1111
* 0x0F ：0000 1111

有关进制之间的转换，详看 [进制](/chapter/java_height_base/hex.md) 章节


以上程序计算分解步骤如下：

在上面说到过，在位计算的时候其实会扩展成int来计算，一个int其实是32位，
这里为了方便观看，使用8位来表示

`hex[(b >> 4) & 0x0f]` 
    
    * b 的二进制形式为：1111 0001
    * 右移4位(高位补0)：0000 1111
    * 按位与(1 & 1 = 1)：0000 0001
    * 结果转为十进制为 15，对于hex数组中的f

`hex[b & 0x0f])` 和上面类似。

作用就是在用位运算，取出每一个4位，得到这个4位对应的16进制表现字符

技巧：利用了 位运算 按位与(1 & 1 = 1) 和 16进制 换算方便的常量，把不需要的位变成了0，再配合右移操作，得到目标数值

上面的程序可以使用一个循环来得到：

```java
    char hex[] = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f'};

    byte b = (byte) 0xf1;
    StringBuffer sb = new StringBuffer("0x");
    for (int i = 1; i <= 2; i++) {
        int num = (2 - i) * 4;
        char t = hex[(b >> num) & 0x0f];
        sb.append(t);
    }
    System.out.println(sb);
```

### 把有符号数字转为无符号

```java
    /**
     * 把data转换为无符号数字；
     * @param data
     * @return 返回 0 - 255 的数字
     */
    public static int getUnsignedByte(byte data) {
        // data & 1111 1111;
        // 只有 1 & 1 = 1;
        /**
         * 1000 0010  -2的源码
         * 1111 1101  -2的反码
         * 111111111111111111111111 1111 1110  -2的补码
         * 00000000000000000000000 1111 1111
         * ----------------------------------
         * 0000000000000000000000 1111 1110
         */
        // 要记住一点，而且是非常重要：位运算是针对整型的，进行位操作时，除long外，其他的类型会自动转成int
        // 所以这里为什么 & 运算之后，一个负数就变成了正数。
        // 这里我按照8位来算，始终都没有搞明白为什么8位的开头是1，却是一个正数
        // java 中的类似是有符号的
//        return Byte.toUnsignedInt(data);
        return data & 0xFF;
    }
```

### 网络协议中的位运算

```bash
| 0xf0 | Msg Bytes 消息体 |
```
0xf0 表示报文类型，1字节，无符号；十进制是240

那么Java中的Byte是有符号的，如果传递的是1字节过来，那么在Java中会解析为一个负数。

用上一小结的 位运算方法能获取到无符号的int数字。


```bash
| 01101000 | Msg bytes |
```
在前面使用无符号的byte来充当报文类型，感觉还是太浪费空间了，那么这里用1byte来标识更多的信息可以这样做：使用二进制，1byte有8个bit位。

比如：规定第三位到第5位(不包含5，索引从1开始) 也就是 01 [10] 1000 中括号括起来的位置来表示消息的紧急程度；

我们该如何正确的获取到这个中括号中标识的十进制呢？

使用按位与和位移操作能获取到；如下代码

```java
    // 01101000
    byte head = (byte) 104;
    // 使用按位与 把第三和第4位提取出来
    int x = head & 0b0011_0000;
    // 把第5位开始的都移走，让目标数字变成最低位
    // 由于上面使用了按位与，所以把不相关的位都变成了0
    // 这里再使用位移操作就得到了我们想要的值
    System.out.println(x >> 4); // 十进制2
```

## 自动装箱的秘密

`Integer i = 100` 相当于编译器自动为您作以下的语法编译：`Integeri= Integer.valueOf(100);`

读过源码的都知道，该方法默认-128 ~ 127 之间的数字使用同一个缓存Integer对象，超过该值的就new一个新的对象返回。

> 在Java8的class中我没有看到编译器的转换Integer.valueOf(100)。在8以前我的确是看到有这样的转换。所以难道是java8的机制变了？

那么为什么要这样设计呢？就涉及到了一个空间的问题；

### 自动装箱的代价

在Java中存储一个对象大概是下面这样
```bash

| 对象头 8字节 | 对象里的各种属性值 | padding填充位
```

请容许我哭一会儿，在百度找了半天没有找到更深入的资料；

就这样大概来看吧。基本类型没有这些额外的数据来记录信息，而包装类有，所以 就很明白了为啥会设置一个缓存机制；

这里看来，HashMap的key只允许包装类，得浪费多少内存

## Java小数的问题
























