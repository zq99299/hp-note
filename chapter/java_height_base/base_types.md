# 基本数据类型

> [官网解释点这里](https://zq99299.gitbooks.io/java-tutorial/content/content/java/nutsandbolts/datatypes.html)

按类型分：

1. 字符类型：char
2. 布尔类似：boolean
3. 数值类型：byte、short、int、long、float、double

按长度分：

1. 未明确定义：boolean
2. 8位（1byte）：byte
3. 16位：char、short
4. 32位：int、float
5：64位：long，double

上面的8中类型，除去boolean和char外，其他的都是有符号的，范围大小是负数~正数。char数据类型是一个16位Unicode字符。它的最小值为'\u0000'（或0），最大值为'\uffff'（或65,535）。

## 位运算
位运算常用在 网络通信、协议解析、高性能编程中。

##### 左移操作 `<<`

_丢弃最高位，用0补位_

左移操作，数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以$$2^{1}$$

##### 右移操作 `>>`

_符号位不变，左边补上符号位_

正数右移，左边补0，负数右移，左边补1

##### 无符号右移操作 `>>>`

_无符号始终补0_

##### 按位与 `&`

_只有 1 & 1 = 1_

```bash
0000 0011  // 十进制 3
0000 0010  // 十进制 2
--------- 按位与
0000 0010  // 结果十进制为 2
```

##### 按位或 `|`

_只有 0 | 0 = 0_

##### 按位取反 `~`

_对二进制按位取反，即 0 变成 1，1 变成 0_


##### 按位异或 `^`

_只有 1 ^ 0 = 1 或则 0 ^ 1 = 1_

### 位运算总结

1. 位运算常用在 网络通信、协议解析、高性能编程中比较常见。
2. 位运算是针对整型的，进行位操作时，除long外，其他的类型会自动转成int
    
    ```bash
    如：byte ba = 127;ba << 2 
    这个运算，ba变量其实扩展成了int
    ```
3. 如果移动的位数超过了32位(long是64位)，那么编译器会对移动的位数取模
    
    如：对int移动33位，33 % 32 = 1，实际上只移动了一位
    
## 位运算实际应用举例

下面这个例子：把变量b打印出它的16进制表现形式
```java
    char hex[] = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f'};

    int b = 0xf1;
    // b = 0xf1
    System.out.println("b = 0x" + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
```

以上程序有1个固定的16进制常量：0xF1 转换为二进制是8个1：1111 0001

以下有几个比较常用的16进制常量：

* 0xFF : 一个F对应4个1，即：1111 1111
* 0x0F ：0000 1111

有关进制之间的转换，详看 [进制](/chapter/java_height_base/hex.md) 章节


以上程序计算分解步骤如下：

在上面说到过，在位计算的时候其实会扩展成int来计算，一个int其实是32位，
这里为了方便观看，使用8位来表示

`hex[(b >> 4) & 0x0f]` 
    
    * b 的二进制形式为：1111 0001
    * 右移4位(高位补0)：0000 1111
    * 按位与(1 & 1 = 1)：0000 0001
    * 结果转为十进制为 15，对于hex数组中的f

`hex[b & 0x0f])` 和上面类似。

作用就是在用位运算，取出每一个4位，得到这个4位对应的16进制表现字符

技巧：利用了 位运算 按位与(1 & 1 = 1) 和 16进制 换算方便的常量，把不需要的位变成了0，再配合右移操作，得到目标数值

上面的程序可以使用一个循环来得到：

```java
    char hex[] = {
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f'};

    byte b = (byte) 0xf1;
    StringBuffer sb = new StringBuffer("0x");
    for (int i = 1; i <= 2; i++) {
        int num = (2 - i) * 4;
        char t = hex[(b >> num) & 0x0f];
        sb.append(t);
    }
    System.out.println(sb);
```


























