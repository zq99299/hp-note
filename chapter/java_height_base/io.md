# IO全接触

## IO里的大小头
首先要明白什么是大小头？

多字节数据在内存中存储的时候，有一个字节顺序问题，和不同的硬件有关；称之为 big endian 和 little endian

 数字 0x1234556在大小头中是下面这样存储的

1. Big endian

    在SUN、IBM的cpu上存储的顺序是这样的；
    
    ```
    | 12 | 34 | 56 | 78      <- 高地址
    ```
    
2. Little Endian x86架构的CPU

    ```
    | 78 | 56 | 34 | 12      <- 高地址
    ```
    
Java IO包中的Bits类,默认使用的是大头
```java
/**
 * Utility methods for packing/unpacking primitive values in/out of byte arrays
 * using big-endian byte ordering.
 */
```

## 装饰器模式：
![](/assets/java_height_base/02/装饰器模式.png)

* Component：组件对象的接口，可以给这些对象动态的添加职责
* ConcreteComponent：具体的组件对象，实现组件对象接口，通常就是被装饰器装饰的原始对象，也就是可以给这个对象添加职责。
* Decorator：所有装饰器的抽象父类，需要定义一个与组件接口一致的接口，并持有一个component对象，其实就是持有一个被装饰的对象。	注意这个被装饰的对象不一定是最原始的那个对象了，也可能是被其他装饰器装饰过后的对象，反正都是实现的同一个接口，也就是同一类型。
* ConcreteDecorator：实际的装饰器对象，实现具体要向被装饰对象添加的功能。

**装饰模式的本质是：** 动态组合【重点是组合】
何时选用：      

1. 如果需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式，这几乎就是装饰模式的主要功能。       
2. 如果不合适使用子类来进行扩展的时候，可以考虑使用装饰模式，因为装饰模式是使用“对象组合”的方式。	所谓不适合用子类扩展的方式，比如：扩展功能需要的子类太多，造成子类数码呈爆炸性增长。

