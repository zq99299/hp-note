# 第01课
## 本课知识点：
*  [基本数据类型](/chapter/java_height_base/base_types.md)
*  [原码、反码、补码 - JVM](/chapter/jvm/code.md) ；[原码、反码、补码](/chapter/java_height_base/code.md)




## 第01题

**以下程序为什么会出错？给出解释，并且纠正错误**

```java
byte ba=127; 
byte bb=ba<<2; 
System.out.println(bb);
```

**答：**

语法规则：在进行位运算的时候，除long外都会提升成int，计算完成后变成了int，赋值给一个byte，精度降低，有可能不再是原来的值了，因为byte的范围是-127~128.

```java
byte ba=127; 
int bb=ba<<2;  // 修改为int接收即可 
System.out.println(bb);
```

## 第02题
**给出 b 和 c 的结果，并且用位移方式图示解释**

```java
int a=-1024;
int b = a>>1;
int c = a>>>1
```

**答案：**

```bash
1111 1111 1111 1111 1111 1100 0000 0000   -1024的补码
---------------------------------------   >> 1
1111 1111 1111 1111 1111 1110 0000 0000   -512

1111 1111 1111 1111 1111 1100 0000 0000   -1024的补码
---------------------------------------   >> 1
0111 1111 1111 1111 1111 1110 0000 0000   2147483136 
```
下面用程序来验证

```java
@Test
public void _02() {
    int a = -1024;
    int b = a >> 1;
    int c = a >>> 1;
    // 11111111111111111111110000000000
    System.out.println(Integer.toBinaryString(a));
    System.out.println(Integer.toBinaryString(b));
    System.out.println(Integer.toBinaryString(c));
    System.out.println(b);
    System.out.println(c);
}

------------- 输出如下---------------

11111111111111111111110000000000
11111111111111111111111000000000
1111111111111111111111000000000    // 注意这里少了一位
-512
2147483136
```

> 本题知识点：
>
> 1. 有符号和无符号位移的区别：无符号始终用0补高位，有符号则补符号位
> 2. 负数在java中以补码形式呈现


## 第03题

**题目：**

定义一个10240*10240的byte数组，分别采用行优先与列优先的循环方式来计算 这些单元格的总和，看看性能的差距，并解释原因
行优先的做法，每次遍历一行，然后到下一行。

这里要明白行优先和列优先,看下面的列子就明白了

```java
 @Test
    public void _03() {
        int[][] arr = new int[5][5];
        for (int i = 0; i < arr.length; i++) {
            int length = arr[i].length;
            for (int j = 0; j < length; j++) {
                arr[i][j] = j;
            }
        }
        System.out.println("------------ 行优先 --------------");
        for (int i = 0; i < arr.length; i++) {
            int length = arr[i].length;
            for (int j = 0; j < length; j++) {
                if (j + 1 == length) {
                    System.out.print(arr[i][j]);
                } else {
                    System.out.print(arr[i][j] + " , ");
                }
            }
            System.out.println("");
        }

        System.out.println("------------ 列优先 --------------");
        for (int i = 0; i < arr.length; i++) {
            int length = arr[i].length;
            for (int j = 0; j < length; j++) {
                if (j + 1 == length) {
                    System.out.print(arr[j][i]);
                } else {
                    System.out.print(arr[j][i] + " , ");
                }
            }
            System.out.println("");
        }
    }
```

这是输出

```bash
------------ 行优先 --------------
0 , 1 , 2 , 3 , 4
0 , 1 , 2 , 3 , 4
0 , 1 , 2 , 3 , 4
0 , 1 , 2 , 3 , 4
0 , 1 , 2 , 3 , 4
------------ 列优先 --------------
0 , 0 , 0 , 0 , 0
1 , 1 , 1 , 1 , 1
2 , 2 , 2 , 2 , 2
3 , 3 , 3 , 3 , 3
4 , 4 , 4 , 4 , 4

可以看出：
行优先的读取顺序是：0,0、0,1、0,2
列优先的读取顺序是：0,0、1,0、2,0
```

**答案：**

```java
@Test
    public void _03_01() {
        byte[][] arr = new byte[10240][10240];
        for (int i = 0; i < arr.length; i++) {
            int length = arr[i].length;
            for (int j = 0; j < length; j++) {
                arr[i][j] = 1;
            }
        }
        _03_01Row(arr);
        _03_01Column(arr);
    }

    private void _03_01Row(byte[][] arr) {
        Instant start = Instant.now();
        int total = 0;
        for (int i = 0; i < arr.length; i++) {
            int length = arr[i].length;
            for (int j = 0; j < length; j++) {
                total += arr[i][j];
            }
        }
        Instant end = Instant.now();
        System.out.println("结果" + total
                + ";耗时：" + Duration.between(start, end).toMillis());
    }

    private void _03_01Column(byte[][] arr) {
        Instant start = Instant.now();
        int total = 0;
        for (int i = 0; i < arr.length; i++) {
            int length = arr[i].length;
            for (int j = 0; j < length; j++) {
                total += arr[j][i];
            }
        }
        Instant end = Instant.now();
        System.out.println("结果" + total
                + ";耗时：" + Duration.between(start, end).toMillis());
    }
```

这是输出

```bash
结果104857600;耗时：54
结果104857600;耗时：3163
```

由于数组的特性 缓存友好性，造成了此差异；在程序启动后就立即生成了数组中的值；

这里可能有一个误区，我以为是初始化的方式问题，结果按照列优先的方式去初始化，结果还是行优先快。然后就去百度了，得到的答案是：c和java的数组都是按 行优先的方式存储的，即一维存储完再继续下一维





