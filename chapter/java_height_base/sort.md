# Java常用排序算法

> 本文摘抄至: 
> * http://blog.csdn.net/daogepiqian/article/details/50770404 
> * http://blog.csdn.net/wuqilianga/article/details/52798728

![](/assets/java_height_base/21457204_1326898064RUxx.jpg)

　排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。
　　内排序有可以分为以下几类：
　　(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。
　　(2)、选择排序：简单选择排序、堆排序。
　　(3)、交换排序：冒泡排序、快速排序。
　　(4)、归并排序
　　(5)、基数排序

## 插入排序
**思想：**每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。

**关键问题：**在前面已经排好序的序列中找到合适的插入位置。

又分为几种实现方式

* 直接插入排序
* 二分插入排序
* 希尔排序

### 直接插入排序

![](/assets/java_height_base/1432702216165801.gif)

**基本思想：**每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（**从后向前找到合适位置**），直到全部插入排序完为止。

算法步骤：

1）将第一待排序序列第一个元素看做一个**有序序列**，把第二个元素到最后一个元素当成是**未排序序列**。

2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置(**从后向前找到合适位置**)。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）


```java
int[] a = {65, 49, 38, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1};
System.out.println(Arrays.toString(a));

for (int i = 1; i < a.length; i++) {
    int temp = a[i]; // 待插入元素
    int k;
    for (k = i - 1; k >= 0; k--) {
        if (a[k] > temp) {
            // 把大于目标值的元素往后移动一位，直到没有比目标元素大的时候
            // 这里最重要的不是交换位置，而是直接往后移动，覆盖掉了目标元素，而目标元素存储在第3个变量中
            a[k + 1] = a[k]; 
        } else {
            break;
        }
    }
    a[k + 1] = temp;
}
```
比如这里的详细流程分析

```bash

第一次：
	i=1; temp = 49;
	比较有序列表：
		第一次：k=0，a[k]=65, 65 > 49? 
				移动前：65，49，38，97，76
				移动后：65，65，38，97，76
				内部循环退出后，K-- = -1;a[k+1] = a[0] = temp;
				把待插入的值插入后: 49,65,38,97,76
第二次：
	i=2;temp = 38;
	比较有序列表：
		第一次：k=1,a[1]= 65, 65 > 38?
			移动前：49,65,38,97,76
			移动后：49,65,65,97,76
			k-- = 0；符合条件再次循环
		第二次：k=0,a[0]=49, 49 > 38?
			移动前：49,65,65,97,76
			移动后：49,49,65,97,76
			k-- = -1,不满足条件，退出内部循环。a[k+1] = a[0] = 38
			插入后：38,49,65,97,76
```