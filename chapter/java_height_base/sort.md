# Java常用排序算法

> 本文摘抄至: 
> * http://blog.csdn.net/daogepiqian/article/details/50770404 
> * http://blog.csdn.net/wuqilianga/article/details/52798728

![](/assets/java_height_base/21457204_1326898064RUxx.jpg)

　排序大的分类可以分为两种：内排序和外排序。在排序过程中，全部记录存放在内存，则称为内排序，如果排序过程中需要使用外存，则称为外排序。下面讲的排序都是属于内排序。
　　内排序有可以分为以下几类：
　　(1)、插入排序：直接插入排序、二分法插入排序、希尔排序。
　　(2)、选择排序：简单选择排序、堆排序。
　　(3)、交换排序：冒泡排序、快速排序。
　　(4)、归并排序
　　(5)、基数排序

##  掌握排序的作用

可以通过某些排序，最快获得一个最大值或则最小值

## 插入排序
**思想：**每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。

**关键问题：**在前面已经排好序的序列中找到合适的插入位置。

又分为几种实现方式

* 直接插入排序
* 二分插入排序
* 希尔排序

### 直接插入排序

![](/assets/java_height_base/1432702216165801.gif)

**基本思想：**每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（**从后向前找到合适位置**），直到全部插入排序完为止。

算法步骤：

1）将第一待排序序列第一个元素看做一个**有序序列**，把第二个元素到最后一个元素当成是**未排序序列**。

2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置(**从后向前找到合适位置**)。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）


```java
int[] a = {65, 49, 38, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1};
System.out.println(Arrays.toString(a));

for (int i = 1; i < a.length; i++) {
    int temp = a[i]; // 待插入元素
    int k;
    for (k = i - 1; k >= 0; k--) {
        if (a[k] > temp) {
            // 把大于目标值的元素往后移动一位，直到没有比目标元素大的时候
            // 这里最重要的不是交换位置，而是直接往后移动，覆盖掉了目标元素，而目标元素存储在第3个变量中
            a[k + 1] = a[k]; 
        } else {
            break;
        }
    }
    a[k + 1] = temp;
}
```
比如这里的详细流程分析

```bash

第一次：
	i=1; temp = 49;
	比较有序列表：
		第一次：k=0，a[k]=65, 65 > 49? 
				移动前：65，49，38，97，76
				移动后：65，65，38，97，76
				内部循环退出后，K-- = -1;a[k+1] = a[0] = temp;
				把待插入的值插入后: 49,65,38,97,76
第二次：
	i=2;temp = 38;
	比较有序列表：
		第一次：k=1,a[1]= 65, 65 > 38?
			移动前：49,65,38,97,76
			移动后：49,65,65,97,76
			k-- = 0；符合条件再次循环
		第二次：k=0,a[0]=49, 49 > 38?
			移动前：49,65,65,97,76
			移动后：49,49,65,97,76
			k-- = -1,不满足条件，退出内部循环。a[k+1] = a[0] = 38
			插入后：38,49,65,97,76
```



## 快速排序

```java
 @Test
    public void q7() {
//        int[] arr = {6, 8, 1, 3, 2, 6, 4};
        int[] arr = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1, 8};
        System.out.println("排序之前：" + Arrays.toString(arr));
        quick(arr);
        System.out.println("排序之后：" + Arrays.toString(arr));
    }

    private static void quick(int[] a) {
        if (a.length > 0) {
            quickSort(a, 0, a.length - 1);
        }
    }

    private static void quickSort(int[] arr, int low, int hight) {
        if (low < hight) {
            int middle = getMiddle(arr, low, hight);
            quickSort(arr, low, middle - 1);
            quickSort(arr, middle + 1, hight);
        }
    }

    private static int getMiddle(int[] a, int low, int hight) {
        // 分5步,核心分4步
        /**
         * 1.从低位找一个基准值
         * 2.从高位开始降低对比找到比基准值还小的数值，然后把这个找到的放到当前的低位
         * 3.从低位开始增高对比找到比基准值还大的数值，然后把这个找到的放到当前的高位
         * 4.把当前的低位放入基准值，这个就是一个分界点，左边的小于基准值，右边的大于等于基准值
         * 5.把左右两拨分开递归调用重复上面的1，2，3，4步骤。
         */
        int base = a[low]; // 基准值
        while (low < hight) {
            System.out.println("----------------------------");
            System.out.println("s:" + Arrays.toString(a));
            // 找到比基准值小的数
            while (low < hight && base <= a[hight]) {
                hight--;
            }
            //找到比基准值小的，则把基准所在的位置 设置上这个小的值
            a[low] = a[hight];
            System.out.println("m:" + Arrays.toString(a));
            // 找到比基准值大的数
            while (low < hight && base >= a[low]) {
                // 如果从左边开始，比基准值小的话，那么要把索引增加，相当于遍历
                low++;
            }
            a[hight] = a[low];
            System.out.println("e:" + Arrays.toString(a));
        }
        a[low] = base;
        return low; // 返回这个中间值
    }
```

```bash
基准值=6
---------------------------- 第一轮
s:[6, 8, 1, 3, 2, 6, 4]    // 在高位找到比基准值小的值
m:[4, 8, 1, 3, 2, 6, 4]    // 找到后，直接把当前的低位（最开始是拿第一个值作为低位的）换成这个小值
e:[4, 8, 1, 3, 2, 6, 8]    // 在低位找到比基准值大的值，
                           // 上一步已经把高位中的一个值存放到基准上面了，所以空缺,就把这个高位插入找到的大值
---------------------------- 第二论
s:[4, 8, 1, 3, 2, 6, 8]
m:[4, 2, 1, 3, 2, 6, 8]
e:[4, 2, 1, 3, 2, 6, 8]

--------------------------- 从两头往中间对比，最后到达中间位置没有可比较的了
[4, 2, 1, 3, 6, 6, 8]	    // 把当前的低位也就是中间位赋值上基准值，就如同这里，基准值左边的始终比基准值小，右边的始终比基准值大,或则相等。 

// 然后分成两拨，继续上面的步骤，直到最后没有可比了，则整个列表就都是有序的了			  

```





