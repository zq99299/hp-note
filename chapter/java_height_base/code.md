# 源码、反码、补码
> 摘抄至 http://www.linuxidc.com/Linux/2015-02/113863.htm

以下例子

| Demo | 7 | -7
| -------------------------
| 原码 | 00000111 | 10000111
| 反码 | 00000111 | 11111000
| 补码 | 00000111 | 11111001

可以看出来，正数的码都一样，_负数的反码：_原码中除去符号位，其他的数值位取反，0变1，1变0。_负数的补码：_其反码+1.   

本篇文章讲解了计算机的原码, 反码和补码. 并且进行了深入探求了为何要使用反码和补码, 以及更进一步的论证了为何可以用反码, 补码的加法计算原码的减法. 

## 机器数和真值
在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.

### 机器数

一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。

### 真值

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

## 原码, 反码, 补码的基础概念和计算方法.
在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.

### 原码

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

```bash
原 0000 0001 = 1

原 1000 0001 = -1
```
第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:
```bash
[1111 1111 , 0111 1111]

即

[-127 , 127]
```
原码是人脑最容易理解和计算的表示方式.

### 反码

反码的表示方法是: 

* 正数的反码是其本身
* 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

```bash
[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反
```

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

### 补码

补码的表示方法是:

* 正数的补码就是其本身
* 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

```bash
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```
对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

## 为何要使用原码, 反码和补码
在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

```bash
[+1] = [00000001]原 = [00000001]反 = [00000001]补

所以不需要过多解释. 但是对于负数:

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0  , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

```bash
1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
```

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

```bash
1 - 1 = 1 + (-1) 
= [0000 0001]原 + [1000 0001]原
= [0000 0001]反 + [1111 1110]反
= [1111 1111]反 
= [1000 0000]原
= -0
```
发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

```bash
1-1 = 1 + (-1) 
= [0000 0001]原 + [1000 0001]原 
= [0000 0001]补 + [1111 1111]补 
= [0000 0000]补
= [0000 0000]原
```

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

```bash
(-1) + (-127) 
= [1000 0001]原 + [1111 1111]原 
= [1111 1111]补 + [1000 0001]补
= [1000 0000]补
```
疑问：这个相加不是超过了8位数了？溢出了？没搞明白
















----------------------------------

原码：所谓原码就是符号位加上数字的二进制表示，int为例，第一位表示符号 (0正数 1负数)简单期间一个字节表示

```bash
+7的原码为： 00000111
-7的原码为： 10000111
```

--------------------

反码：一个数如果为正，则它的反码与原码相同；一个数如果为负，则符号位为1，(符号位不变化，其余位数取反)。
换言之 该数的绝对值取反(绝对值取反各位都取反)。
为了简单起见，我们用1个字节来表示一个整数：

```bash
+7的反码为：00000111
-7的反码为：11111000
```

补码：一个数如果为正，则它的原码、反码、补码相同；一个数如果为负，取到反码然后加1。(反码加1就是补码)为了简单起见，我们用1个字节来表示一个整数：

```bash
+7的补码为： 00000111
-7的补码为： 11111001
```

## int强制转换为byte用补码原码的知识得到正确的值

考虑以下强转
```java
byte a = (byte)508
```

```bash
0000 0001 1111 1100   // 508
1111 1100  // 强制转换后，取最低8位，因为是一个负数，所以这个是补码,十进制=-124
1111 1011  // 根据规则，符号位不变，+1，十进制=-123 
1000 0010  // 
```
这个减1，不用全部换算成十进制来算。右边数第3位`1111 1100`等于1，换算成十进制等于4，4-1 等于3，那么当前位变成0，右边开数1，2位变成1，就组合成了3

